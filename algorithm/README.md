## 部分思路

#### N-Queens
深搜：从第0行开始，对于每一列，检查当前位置是否合法？如果合法则放入一个queen, 进入下一行的迭代，如果不行则回溯到上一行，继续下一个位置的尝试。在判断对于当前i行j列是否合法时，只需要判断向上的三个方向（右上，上，左上）即可。

#### Combination Sum
排序，深搜：遍历所有可能的组合，注意剪枝，同时在递归的过程中要传入一个起始的位置。

```
7 - {2, 3, 6, 7}
     |  |  |  | = 0 (Found)
     |  |  |
     |  |  | = 1
     |  |
     |  | = 4 - {3, 6, 7}
     |           |
     |           | = 1
     |
     | = 5 - {2, 3, 6, 7}
              |
              | = 3 - {2, 3}
                       |  |
                       |  | = 0 (Found)
                       |
                       | = 1
```

#### Reverse List, 反转链表

```
0:  NULL    [1] -> [2] -> [3] -> [4] -> NULL
     ^       ^
   prev     cur

1:  NULL <- [1]    [2] -> [3] -> [4] -> NULL
             ^      ^
           prev    cur

2:  NULL <- [1] <- [2]    [3] -> [4] -> NULL
                    ^      ^
                  prev    cur

3:  NULL <- [1] <- [2]    [3]    [4] -> NULL
                           ^      ^
                         prev    cur

4:  NULL <- [1] <- [2] <- [3]    [4] -> NULL
                           ^      ^
                         prev    cur

5:  NULL <- [1] <- [2] <- [3] <- [4]    NULL
                                  ^      ^
                                 prev    cur
```

#### Reverse Words in a String
将字符串按照空格分割开，然后消除每个单词头部和尾部可能存在的空格，得到所有合法的单词后重新拼接成结果。

#### Triangle
这道题目本以为可以转换成图然后Dijkstra求出最短路，复习之后准备开始实现的时候Google了一下发现原来可以用DP完成，算法复杂度和空间复杂度都只需要`O(n)`, 智商啊，情何以堪！
递推方程如下：
```
minV[j] = min(minV[j], minV[j + 1]) + triangle[i][j]
```
从底向上计算。
